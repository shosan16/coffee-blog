---
description:
globs: *.test.ts
alwaysApply: false
---
# TypeScript テスト作成のためのルール

## 役割定義

あなたは、TypeScript/JavaScript、フロントエンド開発、バックエンド開発、Vitest、React Testing Libraryを使った単体テストのエキスパートです。簡潔で技術的なコードを、正確な例と正しい型情報を用いて記述します。

## テストアプローチの選択

### 古典学派アプローチ（推奨）

- 共有依存（DB、ファイルシステム）のみモック化
- ユニット = ユースケース（複数クラスの協調も含む）
- より現実的で堅牢なテスト
- リファクタリング耐性が高い

### ロンドン学派アプローチ

- すべての依存をモック化
- ユニット = 単一クラス
- 素早いフィードバック
- 原因特定が容易

## 基本原則

### テストの目的と哲学

**テストは持続可能な開発を実現するための設計手法である**

- 単にコードが動くことを担保するだけではない
- 質の悪いテストは、テストなしの状態と同様に持続的な成長を妨げる
- コードは資産ではなく負債 - テストコードも同様に最小限に保つ

### 良い単体テストの4本の柱

1. **退行（regression）に対する保護**
   - バグの再発を防ぐ能力
   - 含まれるプロダクションコードが多いほど保護力が高い

2. **リファクタリングへの耐性**
   - 偽陽性（false positive）を避ける
   - 実装の詳細ではなく振る舞いをテスト
   - リファクタリング時にテストが壊れない

3. **迅速なフィードバック**
   - テストの実行速度
   - 問題の早期発見

4. **保守のしやすさ**
   - テストコードの理解しやすさ
   - 変更の容易さ

### テスト設計の指針

1. **認知負荷の最小化**
   - テストケースは単一の振る舞いに焦点を当てる
   - 説明的で意味のあるテスト名を使用（日本語も可）
   - AAA（Arrange-Act-Assert）パターンに従う
   - 共通のセットアップはヘルパー関数として抽出
   - テストコードはSystem 1（直感的思考）で理解できるように

2. **脆いテストの回避**
   - 実装の詳細ではなく、振る舞いをテストする
   - 固定値のタイムアウトを避け、waitForやfindByを活用
   - 外部依存関係は適切にモック化
   - テスト間の依存関係を排除
   - ブラックボックステストを優先

3. **保守性の確保**
   - DRY原則に従い、重複を排除
   - data-testid属性による安定した要素選択
   - 適切なエラーメッセージで失敗理由を明確化
   - テストの意図が明確になるよう構造化

## テストフレームワーク設定

### ファイル構造

- テストファイルは対象ファイルと同じディレクトリに配置
- 命名規則: `*.test.ts` または `*.test.tsx`
- グローバル設定は `vitest.config.ts` で管理
- テストユーティリティは `test-utils` ディレクトリに集約

## テスト記述のガイドライン

### テストの種類と選択

1. **出力ベースのテスト（最も推奨）**
   - 純粋関数のテスト
   - 副作用なし、決定的な出力
   - 最も質が高く、保守しやすい

2. **状態ベースのテスト**
   - オブジェクトの状態変化を検証
   - 実行後の状態を確認

3. **コミュニケーションベースのテスト**
   - モックを使用した相互作用の検証
   - 必要最小限に留める

### 1. 構造化

テストは、AAA（Arrange-Act-Assert）パターンに従って作成してください。
また、各ステップの直上には**その内容を簡潔にまとめたコメント（要約文）**を記載してください。

さらに、コードの意図がひと目で伝わりにくい箇所については、例の `// 軽減税率（8%）` のように、補足コメントを明記するようにしてください。

```js
describe('コンポーネント/関数名', () => {
  describe('機能/シナリオ', () => {
    it('期待される動作を明確に記述', () => {
      // Arrange - 準備： 準備に関する要約文
      // Act - 実行： 実行に関する要約文
      // Assert - 確認： 確認に関する要約文
    });
  });
});
```

例：

```js
describe('calculateTaxForSimplifiedInvoice', () => {
  describe('税込価額を税率ごとに区分して合計した金額に対して税額を計算した場合', () => {
    it('端数を切り捨てること', () => {
      // Arrange - 準備：適格簡易請求書を作成し、品目を追加
      const inv = createSimplifiedInvoice();
      inv.add(new Item('技評茶', 130, 飲料), 2);   // 軽減税率（8%）
      inv.add(new Item('技評酒', 150, 酒類), 3);   // 標準税率（10%）

      // Act - 実行：合計金額（含む税額）を計算
      const total = inv.total();

      // Assert - 確認：税率ごとの税額、および合計税額を検証
      assert.deepEqual(total.tax, {
        reduced: 19,   // (130*2)*(8/108) = 19.25 → 切り捨てて 19
        standard: 40,  // (150*3)*(10/110) = 40.90 → 切り捨てて 40
        total: 59      // 19 + 40
      });
    });
  });
});
```

### 2. 要素選択の優先順位

1. `getByRole` - アクセシビリティを考慮
2. `getByLabelText` - フォーム要素
3. `getByPlaceholderText` - 入力フィールド
4. `getByText` - テキストコンテンツ
5. `getByTestId` - 最終手段

### 3. 非同期処理

- `async/await` を使用して非同期操作を処理
- `waitFor` で状態変更を待機
- `findBy` クエリで要素の出現を待つ
- Promise の解決を適切に待機
- 固定のタイムアウトは避ける

### 4. モッキング戦略

#### 古典学派的アプローチ（推奨）

- **共有依存のみモック化**：データベース、ファイルシステムなど
- **管理下の依存はモック化しない**：アプリケーション内のクラス
- **純粋関数を増やす**：副作用を分離し、テスト可能性を向上

#### モック使用の原則

- `vi.mock()` - 外部モジュールのモック
- `vi.fn()` - モック関数の作成
- `vi.spyOn()` - 既存メソッドのスパイ
- 各テスト後に `vi.clearAllMocks()` でリセット

#### モックすべきもの

- **管理外のプロセス外依存**：外部API、メールサービスなど
- **共有リソース**：データベース（テスト用インスタンスが望ましい）
- **非決定的な要素**：現在時刻、ランダム値

#### モックすべきでないもの

- **内部実装の詳細**：プライベートメソッド、内部状態
- **管理下の依存**：アプリケーション内のクラス
- **スタブの振る舞い**：検証は出力のみ、相互作用は検証しない

## React Testing Libraryベストプラクティス

### ユーザーインタラクション

- `userEvent.setup()` でイベントハンドラを初期化
- クリック、タイピング、選択はuserEvent経由で実行
- 非同期操作には必ず `await` を使用

### コンポーネントテスト

- プロバイダーラッパーを作成して再利用
- propsの組み合わせを網羅的にテスト
- エラー境界のテストも実施
- 実装の詳細ではなくユーザーの視点でテスト

### 統合テスト

1. **コンポーネント統合テスト**
   - 複数のコンポーネントの連携を検証
   - 実際のユーザーフローに沿ったテスト
   - モックは最小限に留める

2. **API統合テスト**
   - MSW（Mock Service Worker）の活用
   - ネットワークレベルでのモック
   - エラーレスポンスのシミュレーション
   - レスポンスの遅延やタイムアウトのテスト

## Next.js固有の考慮事項

### ルーティング関連

- `useRouter`, `useSearchParams`, `usePathname` のモック
- ページ遷移のシミュレーション
- クエリパラメータの処理テスト

### サーバーコンポーネント

- 非同期レンダリングの適切な処理
- サーバー/クライアント境界の考慮
- データフェッチングのモック

## 品質基準

### カバレッジ目標

- 全体: 80%以上
- ビジネスロジック: 90%以上
- ユーティリティ関数: 100%
- **注意**: カバレッジは品質の指標の一つに過ぎない

### テスト実行結果の活用

1. **信号機としての役割**
   - 成功/失敗を色で即座に判断（緑/赤）
   - 終了コードによる自動化

2. **問題箇所の特定**
   - 何が失敗したか：説明的なテスト名
   - どこで失敗したか：明確なエラーメッセージ
   - どのように失敗したか：期待値と実測値の表示

3. **ドキュメントとしての活用**
   - テスト名が仕様書として機能
   - 実行結果が開発進捗の指標

### テスト実行

- 開発時: `npm run test` (watch mode)
- CI/CD: `npm run test:coverage`

## ベストプラクティス

### データ管理

1. **リアルなテストデータ**
   - Faker.jsやChanceを使用した疑似データ生成
   - プロパティベースドテスト（fast-check）の活用
   - ハードコードされた値より動的な値を優先

2. **テストの独立性**
   - 各テストは独自のデータセットを作成
   - 共有データに依存しない
   - beforeEachで環境をリセット

3. **最小限の情報量**
   - テストに必要な情報のみを含める
   - 重要な詳細は明示的に
   - 無関係な詳細はヘルパー関数に隠蔽

### エラーハンドリング

1. **適切なアサーション**

   ```javascript
   // 👎 悪い例
   expect(error).toBeTruthy();

   // 👍 良い例
   await expect(addProduct({}))
     .rejects.toThrow(ValidationError)
     .toHaveProperty('code', 'INVALID_INPUT');
   ```

2. **失敗時の情報量**
   - 具体的な期待値と実測値を表示
   - エラーの種類とメッセージを明確に
   - デバッグに必要な情報を含める

### スナップショットテスト

- 短く焦点を絞ったインラインスナップショット
- 3-7行程度に収める
- 外部ファイルのスナップショットは避ける
- UIの構造より振る舞いを重視

## アンチパターン

### 避けるべき実践

- **テスト内での条件分岐・反復文の使用**：`if`、`switch`、`for`、`while`などの制御構文の使用
- **実装詳細に依存したテスト**：内部構造やプライベートメソッドのテスト
- **スナップショットテストの過度な使用**：大きな外部ファイルのスナップショット
- **グローバル状態の直接変更**：テスト間で状態を共有
- **テスト実行順序への依存**：順序に依存するテストは脆弱
- **ハードコードされたタイムアウト**：`setTimeout`の固定値使用
- **共有状態を持つテスト**：他のテストに影響を与える

### 典型的なアンチパターン

1. **過剰な検証（Over-specification）**
   - スタブの呼び出し回数や引数の検証
   - 実装の詳細な動作順序の検証

2. **テストへのドメイン知識の漏洩**
   - プロダクションコードのロジックをコピー
   - テスト内で複雑な計算を再実装

3. **プロダクションコードへの汚染**
   - テスト専用のコードやフラグ
   - テストのためだけのpublicメソッド

4. **不適切なモック化**
   - 具象クラスのモック化
   - 管理下の依存のモック化
   - モックの過剰使用

### コード品質

- **明確な失敗メッセージ**：デバッグを容易に
- **テストの独立性を保証**：並列実行可能に

## 実装指針

### セットアップとクリーンアップ

1. **適切な使用**
   - `beforeEach`/`afterEach`：各テストの環境初期化
   - `beforeAll`/`afterAll`：高コストなセットアップのみ
   - テスト前のクリーンアップが推奨

2. **エラーハンドリング**
   - 予期されるエラーケースを網羅
   - エラー時のUI表示を検証
   - 適切なエラーメッセージの確認

3. **パフォーマンス**
   - Vitestの高速実行とHMRを活用
   - 並列実行を考慮した設計
   - 不要なレンダリングを避ける
   - テストのグループ化とタグ付け

## 特殊なケースの扱い

### 現在日時の扱い

1. **依存性注入**：日時を引数として渡す
2. **タイマーのモック**：`vi.useFakeTimers()`
3. **固定値の使用**：テスト環境での予測可能な値

### 統合テスト

- **最小限のハッピーパス**：主要な成功シナリオ
- **管理下の依存は実物を使用**：DB、内部サービス
- **管理外の依存はモック**：外部API、サードパーティ
- **トランザクション境界の明確化**
